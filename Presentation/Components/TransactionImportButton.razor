@using Application
@using Fluxor
@using Presentation.Store.Transaction

@inject ITransactionCsvImporter _transactionCsvImporter
@inject IDispatcher _dispatcher

@{
    var selectedColumns = Columns.GroupBy(c => c);
    var hasDate = selectedColumns.Any(g => g.Key == "Date");
    var hasCharge = selectedColumns.Any(g => g.Key == "Charge");
    var hasClass = selectedColumns.Any(g => g.Key == "Class");
    var hasDetails = selectedColumns.Any(g => g.Key == "Details");
}
<div style="background-color: @(hasDate ? "green" : "red")">Date</div>
<div style="background-color: @(hasCharge ? "green" : "red")">Charge</div>
<div style="background-color: @(hasClass ? "green" : "red")">Class</div>
<div style="background-color: @(hasDetails ? "green" : "red")">Details</div>
@{ var canImport = hasDate && hasCharge && hasClass && hasDetails; }
<button disabled="@(!canImport)" @onclick="@HandleImportClickedAsync">Import</button>

@code {

    [Parameter]
    public string[] Columns { get; set; } = Array.Empty<string>();

    [Parameter]
    public string CsvText { get; set; } = String.Empty;

    [Parameter]
    public Action OnImported { get; set; } = () => { };

    private async Task HandleImportClickedAsync()
    {
        var csvHeaderStr = String.Join(",", Columns) + "\n";
        var transactions = await _transactionCsvImporter
            .ImportTransactions(CsvText, csvHeaderStr);
        _dispatcher.Dispatch(new TransactionCsvLoadAction(transactions));
        
    }

}