@using Application
@using Domain
@using Fluxor
@using Presentation.Store.Import
@using Presentation.Store.Transaction

@inject ITransactionCsvImporter _transactionCsvImporter
@inject IDispatcher _dispatcher

@{
    var selectedColumns = Columns.GroupBy(c => c);
    // Mandatory
    var hasDate = selectedColumns.Any(g => g.Key == nameof(Transaction.Date));
    var hasCharge = selectedColumns.Any(g => g.Key == nameof(Transaction.Charge));
    var hasDetails = selectedColumns.Any(g => g.Key == nameof(Transaction.Details));
    // Optional
    var hasGroup = selectedColumns.Any(g => g.Key == nameof(Transaction.Group));
    var hasBalance =  selectedColumns.Any(g => g.Key == nameof(Transaction.Balance));
    var hasMerchant =  selectedColumns.Any(g => g.Key == nameof(Transaction.Merchant));
    var hasClass = selectedColumns.Any(g => g.Key == nameof(Transaction.Class));
}

<div>First row is heading <input type="checkbox" @bind="@_firstRowIsHeading"/></div>
@* Mandatory *@
<div style="background-color: @(hasDate ? "green" : "red")">@nameof(Transaction.Date)</div>
<div style="background-color: @(hasCharge ? "green" : "red")">@nameof(Transaction.Charge)</div>
<div style="background-color: @(hasDetails ? "green" : "red")">@nameof(Transaction.Details)</div>
@* Optional *@
<div style="background-color: @(hasBalance ? "green" : "orange")">@nameof(Transaction.Balance)</div>
<div style="background-color: @(hasGroup ? "green" : "orange")">@nameof(Transaction.Group)</div>
<div style="background-color: @(hasMerchant ? "green" : "orange")">@nameof(Transaction.Merchant)</div>
<div style="background-color: @(hasClass ? "green" : "orange")">@nameof(Transaction.Class)</div>

@{ var canImport = hasDate && hasCharge && hasDetails; }
<button disabled="@(!canImport)" @onclick="@HandleImportClickedAsync">Import</button>

@code {

    private bool _firstRowIsHeading = false;
    
    [Parameter]
    public string[] Columns { get; set; } = Array.Empty<string>();

    [Parameter]
    public string CsvText { get; set; } = String.Empty;

    [Parameter]
    public Action OnImported { get; set; } = () => { };

    private async Task HandleImportClickedAsync()
    {
        
        // TODO: Validate imports for duplicates:
        //         var existingTransactions = await _transactionRepository.Read();
        //         var existingTransactionsList = existingTransactions.ToArray();
        //             
        //         var importedTransactions = action.Transactions;
        //         var addTransactions = new List<Domain.Transaction>();
        //         foreach (var transaction in importedTransactions)
        //         {
        //             var alreadyImported = existingTransactionsList
        //                 .Any(t => t.ToHash().ToString() == transaction.ToHash().ToString());
        //             if (alreadyImported) continue;
        //
        //             transaction.Id = Guid.NewGuid();
        //             addTransactions.Add(transaction);
        //         }
        
        var csvHeaderStr = String.Join(",", Columns) + "\n";
        var transactions = (await _transactionCsvImporter
            .ImportTransactions(CsvText, csvHeaderStr, _firstRowIsHeading))
            .ToArray();
        
        var dateNow = DateTime.Now;
        var transactionIds = transactions.Select(t => t.Id);
        var imports = new [] { new Import(dateNow, transactionIds) };
        _dispatcher.Dispatch(new ImportCreateAction(imports));
        _dispatcher.Dispatch(new ImportRepoCreateAction(imports));
        
        var importedTransaction = new TransactionCreateAction(transactions);
        _dispatcher.Dispatch(importedTransaction);

        var repoLoadAction = new TransactionRepoCreateAction(transactions);
        _dispatcher.Dispatch(repoLoadAction);
    }

}